# Общие важные пункты

- Писать код нужно модульно. Разделяйте код на отдельные функции, которые можно применить в другом месте. Можно разделять даже на отдельные файлы, если это оправдано.

- Учитывайте, что части вашего кода могут отдельно применяться в других местах. Как файлы и массивы, так и функции. Оставляйте возможность получать эти доступы. Желательно прочитать все модули и понять как они связаны

- Не забываем, что мы делаем эксперимент. Где уместно - сделайте график для наглядности, сохраните промежуточные данные. Обрабатывайте маленькие датасеты на 1000 текстов и смотрите как работает

- Писать код нужно с комментариями. Комментарии должны быть в каждой строке с подробным описанием работы каждой строки. В начале каждой функции должно быть подробное описание функции. Описание должно отвечать на вопросы: 
  - Что делает функция. Главная её задача и цель
  - С какими функциями связана эта функция. Где её применяют и какие она применяет
  - Как функция выполняет цель и задачу
  - Пример использования функции, в том числе ожидаемый результат
  - Опционально допустимо покрытие тестами

- Писать код нужно с оглядкой на то, что нам нужно обрабатывать 80 ГБ датасета, который может сгенерировать около ТБ временных файлов в процессе работы, которые нужно обрабатывать.

- Код должен не просто молча выполняться, но сообщать что он делает и за какое время. Всё время держать в курсе пользователя

- Все обновления кода должны сопровождать описания этих изменений в гитхабе, в том числе первое внесение должно подробно описывать что делает программа и какие могут возникнуть сложности или проблемы при использовании.

- В коде необходимо указывать комментариями важные участки, которые могут привести к остановке программы, например из-за переполнения памяти

- Не забываем удалять неиспользуемые данные в процессе работы, если они не будут нужны в дальнейшем

## Модуль обработки датасета

1. Скачиваем данные из csv файла и помещаем в рабочий массив
2. Передаём этот массив функции кодирования текста. На выходе получаем массив с тензорами
3. Массив с тензорами передаётся функции выполняющей косинусное сходство. Результатом являются массивы с матрицами схожести, а также агрегированные данные для гистограммы
4. Матрицы схожести записываются в csv файл
5. Агрегированные данные возвращают гистограмму пользователю

### Требует доработки:
- Запись матриц схожести в csv файл
- Запись банчами
- Оптимизация потребления памяти диска
- Убрать дубли и ненужные временные файлы
- Оптимизация скорости выполнения
- Заменить все динамические массивы на статические

## Модуль кластеризации текста

1. Инициализируем кодировщик
2. Берем массив закодированных текстов и передаём кодировщику. На выходе получаем массив с кластерами

## Модуль дообучения и оценки результата

1. Инициализируется модель
2. На вход есть 2 варианта: получить массив с текстами, тогда нужно кодировать или получить на вход тензора(уже закодированное)
3. Оценивается результат работы

## Модуль нахождения среднего тензора кластера

1. Берём массив кластеризованных текстов
2. Передаём каждый кластер из массива функции определения среднего тензора, эти функции могут быть разными. На выходе получается массив средних тензоров, который привязан к массиву кластеров
3. Формируем массив со средними тензорами для каждого кластера

### Примеры функций:
Tср=1VVTdV, i=0N1NTi

## Экспериментальное определение требуемых параметров для каждого кластера

1. Кодируем при помощи кодировщика нейросети, которую будем обучать. Используем для этого модуль обработки датасета
2. Проводим кластеризацию тензоров. Используем для этого модуль кластеризации тензоров
3. Считаем ВЕС каждого кластера в нашем датасете. 
4. Записываем его в отдельный массив, связанный с кластерами. В дальнейшем это нам поможет как оценки проводить, так и достраивать датасет
5. Внутри кластера проводим косинусное сходство. Используем для этого модуль обработки датасета
6. Все тексты со схожестью меньше СХОЖЕСТЬ перекидываем в финальный датасет и удаляем из рабочего. Переброска не меняет кластер и прочие параметры
7. Для текстов со схожестью больше СХОЖЕСТЬ находим средний тензор.
8. Записываем средний тензор в массив ЭКСПЕРИМЕНТ.
9. Проводим дообучение модели и оцениваем результат. Используем для этого модуль дообучения и оценки результата.
10. Определяем какое число ДУБЛИ необходимо, чтобы модель начинала показывать лучший результат в работе с данным средним тензором, а также с кластером в целом
11. Добавляем копии среднего тензора без изменений в количестве ДУБЛИ штук в итоговый массив.
12. Модифицируем средний тензор используя модуль нахождения среднего тензора - находим средний между средним и случайным из кластера
13. Определяем какое число ВАРИАЦИИ модифицированных тензоров необходимо, чтобы модель начинала показывать лучший результат работы с данными тензорами, а также кластером в целом
14. Добавляем ВАРИАЦИИ модифицированных тензоров в итоговый массив
15. Обрабатываем таким образом весь датасет
16. Итоговый массив преобразуем в датасет
    - Либо это датасет, состоящий из тензоров
    - Либо это датасет, состоящий из текста
17. Тогда нужно декодировать тензора в текст, даже если это будет каша и провести эксперименты как в пункте выше.
